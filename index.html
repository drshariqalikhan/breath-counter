<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Adaptive Breath Monitor with Chart</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> <!-- Include Chart.js -->
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 15px; background-color: #f4f4f4; color: #333; display: flex; flex-direction: column; align-items: center; text-align: center; }
        .container { background-color: #fff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); width: 100%; max-width: 420px; }
        h1 { color: #007aff; margin-bottom: 10px; font-size: 24px; }
        button { background-color: #007aff; color: white; border: none; padding: 10px 18px; font-size: 15px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s; margin-bottom: 8px; margin-right: 5px;}
        button:hover { background-color: #005ecb; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #collectDataButton { background-color: #34c759; }
        #collectDataButton:hover { background-color: #2ca349; }
        .data-display { margin-bottom: 10px; padding: 8px; background-color: #e9e9eb; border-radius: 4px; }
        .data-display p { margin: 4px 0; font-size: 15px; }
        .data-display span { font-weight: bold; color: #333; }
        #breathRateDisplay { font-size: 22px; color: #28a745; }
        #movementDisplay { color: #17a2b8; font-weight: bold; font-size: 16px; }
        .chart-container {
            width: 100%;
            max-width: 380px; /* Ensure it fits well */
            margin: 10px auto; /* Center it */
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
        }
        #logArea { width: 100%; height: 100px; border: 1px solid #ccc; border-radius: 4px; padding: 8px; font-family: monospace; font-size: 10px; overflow-y: scroll; box-sizing: border-box; background-color: #f9f9f9; margin-top:5px;}
        .instructions { font-size: 12px; color: #555; margin-bottom: 8px; text-align: left; padding: 8px; background-color: #fff3cd; border: 1px solid #ffeeba; border-radius: 4px; }
        .instructions ul {padding-left: 18px; margin-top: 4px;}
        .instructions li {margin-bottom: 2px;}
        .important-note { font-size: 11px; color: #555; margin-top:4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Adaptive Breath Monitor</h1>
        <div class="instructions">
            <strong>Phone Placement:</strong> TOP edge points to your LEFT side on tummy.
            <strong>Operation:</strong>
            <ol>
                <li>Tap "Start System" & grant permissions.</li>
                <li>Tap "Start 1-Min Data Collection" and breathe normally.</li>
                <li>After analysis, breathing will be monitored on the chart.</li>
            </ol>
        </div>

        <button id="startButton">Start System</button>
        <button id="collectDataButton" style="display: none;">Start 1-Min Data Collection</button>

        <div class="data-display">
            <p>Status: <span id="movementDisplay">--</span></p>
        </div>
        <div class="data-display">
            <p>Breath Rate: <span id="breathRateDisplay">--</span> BPM</p>
        </div>
        
        <div class="chart-container">
            <canvas id="breathChart"></canvas>
        </div>

        <div class="data-display" style="font-size:11px; text-align:left;">
            <p>Raw Beta (Gyro X-tilt): <span id="betaGyroDisplay">--</span> °</p>
            <p>Learned Threshold: <span id="learnedThresholdDisplay">--</span> °</p>
            <p>Raw Z-Accel (FYI): <span id="zAccelDisplay">--</span> m/s²</p>
        </div>
        <p class="important-note">Remain still (except breathing) during data collection for best results.</p>
        <h2>Event & Error Log</h2>
        <textarea id="logArea" readonly></textarea>
    </div>

    <script>
        const startButton = document.getElementById('startButton');
        const collectDataButton = document.getElementById('collectDataButton');
        const movementDisplay = document.getElementById('movementDisplay');
        const breathRateDisplay = document.getElementById('breathRateDisplay');
        const betaGyroDisplay = document.getElementById('betaGyroDisplay');
        const learnedThresholdDisplay = document.getElementById('learnedThresholdDisplay');
        const zAccelDisplay = document.getElementById('zAccelDisplay');
        const logArea = document.getElementById('logArea');
        const breathChartCanvas = document.getElementById('breathChart');

        let systemActive = false; 
        let isMonitoringBreaths = false; 
        let lastBeta = null;
        let breathState = 'IDLE';
        let breathTimestamps = [];
        const MAX_TIMESTAMPS_FOR_BPM = 10;
        
        let LEARNED_BETA_TILT_THRESHOLD = 0.1; 
        const MIN_BREATH_INTERVAL_MS = 1000; 
        let lastBreathEventTime = 0;

        let audioContext = null;

        const DATA_COLLECTION_DURATION_S = 60;
        let dataCollectionState = 'IDLE'; 
        let dataCollectionTimer = null;
        let recordedBetaValues = [];
        const STD_DEV_MULTIPLIER_FOR_THRESHOLD = 1.2; 

        let breathChart = null;
        const MAX_CHART_DATA_POINTS = 150; // Number of data points to show on chart
        let chartLabelCounter = 0;


        function logMessage(message, type = 'INFO') { /* ... (same) ... */ 
            const now = new Date();
            const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            logArea.value += `[${timeString} ${type}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }
        async function lockScreenOrientation() { /* ... (same) ... */
            try {
                if (screen.orientation && typeof screen.orientation.lock === 'function') {
                    await screen.orientation.lock('portrait-primary');
                    logMessage('Screen orientation locked.');
                } else { logMessage('Screen lock API not fully supported.', 'WARN'); }
            } catch (error) { logMessage(`Screen lock error: ${error.message}`, 'WARN'); }
         }
        function initializeAudioContext() { /* ... (same) ... */
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    logMessage('AudioContext initialized.');
                } catch (e) { logMessage('Web Audio API not supported.', 'ERROR'); audioContext = null; }
            } else if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => logMessage('AudioContext resumed.'))
                                     .catch(e => logMessage('Failed to resume AudioContext.', 'ERROR'));
            }
         }
        function playBeep(duration = 0.07, frequency = 900, volume = 0.25) { /* ... (same) ... */ 
            if (!audioContext || audioContext.state !== 'running') return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = 'sine';
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) { logMessage(`Error playing beep: ${e.message}`, 'ERROR'); }
        }

        function initBreathChart() {
            if (breathChart) {
                breathChart.destroy(); // Destroy existing chart if any
            }
            const ctx = breathChartCanvas.getContext('2d');
            breathChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Gyro Beta (X-Tilt)',
                        data: [],
                        borderColor: 'rgb(0, 122, 255)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.2, // Smoothens the line a bit
                        pointRadius: 0 // No dots on data points
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0 // Disable animation for real-time feel
                    },
                    scales: {
                        x: {
                            display: false // Hide x-axis labels for simplicity
                        },
                        y: {
                            // beginAtZero: false, // Auto scale
                            title: {
                                display: true,
                                text: 'Beta Tilt (°)'
                            },
                            ticks: {
                                font: { size: 10 }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
            chartLabelCounter = 0;
            logMessage('Breath chart initialized.');
        }

        function updateBreathChart(value) {
            if (!breathChart) return;

            breathChart.data.labels.push(chartLabelCounter++);
            breathChart.data.datasets[0].data.push(value);

            if (breathChart.data.labels.length > MAX_CHART_DATA_POINTS) {
                breathChart.data.labels.shift();
                breathChart.data.datasets[0].data.shift();
            }
            breathChart.update('none'); // 'none' prevents animation for faster updates
        }
        
        function resetChartData() {
            if (breathChart) {
                breathChart.data.labels = [];
                breathChart.data.datasets[0].data = [];
                breathChart.update('none');
                chartLabelCounter = 0;
            }
        }


        function startDataCollection() { /* ... (same as before) ... */ 
            if (!systemActive) {
                logMessage('System not active. Click "Start System" first.', 'WARN'); return;
            }
            if (dataCollectionState === 'COLLECTING') {
                logMessage('Data collection already in progress.', 'INFO'); return;
            }

            isMonitoringBreaths = false; 
            startButton.disabled = true;
            collectDataButton.disabled = true;
            collectDataButton.textContent = 'Collecting Data...';
            dataCollectionState = 'COLLECTING';
            recordedBetaValues = [];
            resetChartData(); // Clear chart before new collection
            movementDisplay.textContent = `Collecting data for ${DATA_COLLECTION_DURATION_S}s... Breathe normally.`;
            logMessage(`Starting ${DATA_COLLECTION_DURATION_S}s data collection.`);
            
            let countdown = DATA_COLLECTION_DURATION_S;
            const countdownInterval = setInterval(() => {
                countdown--;
                if (dataCollectionState === 'COLLECTING') {
                    movementDisplay.textContent = `Collecting data... ${countdown}s remaining. Breathe normally.`;
                }
                if (countdown <= 0) {
                    clearInterval(countdownInterval);
                }
            }, 1000);

            dataCollectionTimer = setTimeout(() => {
                clearInterval(countdownInterval); 
                if (dataCollectionState === 'COLLECTING') {
                    finishDataCollectionAndAnalyze();
                }
            }, DATA_COLLECTION_DURATION_S * 1000);
        }

        function finishDataCollectionAndAnalyze() { /* ... (same analysis logic) ... */ 
            dataCollectionState = 'ANALYZING';
            movementDisplay.textContent = 'Analyzing data... Please wait.';
            logMessage(`Data collection finished. Recorded ${recordedBetaValues.length} Beta samples. Analyzing...`);

            setTimeout(() => {
                if (recordedBetaValues.length < 20) { 
                    logMessage('Not enough data. Using default threshold.', 'WARN');
                    LEARNED_BETA_TILT_THRESHOLD = 0.1; 
                    learnedThresholdDisplay.textContent = `${LEARNED_BETA_TILT_THRESHOLD.toFixed(3)}° (default)`;
                } else {
                    const deltaBetas = [];
                    for (let i = 1; i < recordedBetaValues.length; i++) {
                        deltaBetas.push(recordedBetaValues[i] - recordedBetaValues[i-1]);
                    }

                    if (deltaBetas.length === 0) {
                        logMessage('No delta Beta. Using default threshold.', 'WARN');
                        LEARNED_BETA_TILT_THRESHOLD = 0.1;
                        learnedThresholdDisplay.textContent = `${LEARNED_BETA_TILT_THRESHOLD.toFixed(3)}° (default)`;
                    } else {
                        const absDeltaBetas = deltaBetas.map(d => Math.abs(d));
                        const significantAbsDeltaBetas = absDeltaBetas.filter(d => d > 0.001); 

                        if (significantAbsDeltaBetas.length < 10) {
                             logMessage('Not enough significant deltas. Using sensitive default.', 'WARN');
                             LEARNED_BETA_TILT_THRESHOLD = 0.05; 
                             learnedThresholdDisplay.textContent = `${LEARNED_BETA_TILT_THRESHOLD.toFixed(3)}° (sensitive default)`;
                        } else {
                            const sum = significantAbsDeltaBetas.reduce((acc, val) => acc + val, 0);
                            const mean = sum / significantAbsDeltaBetas.length;
                            const sqDiffs = significantAbsDeltaBetas.map(val => Math.pow(val - mean, 2));
                            const avgSqDiff = sqDiffs.reduce((acc, val) => acc + val, 0) / significantAbsDeltaBetas.length;
                            const stdDev = Math.sqrt(avgSqDiff);

                            LEARNED_BETA_TILT_THRESHOLD = Math.max(0.02, STD_DEV_MULTIPLIER_FOR_THRESHOLD * stdDev); 
                            logMessage(`Analysis complete. Mean Abs Delta: ${mean.toFixed(4)}, StdDev Abs Delta: ${stdDev.toFixed(4)}`);
                            learnedThresholdDisplay.textContent = `${LEARNED_BETA_TILT_THRESHOLD.toFixed(3)}° (learned)`;
                        }
                    }
                }
                logMessage(`Learned Threshold set to: ${LEARNED_BETA_TILT_THRESHOLD.toFixed(3)}°`);
                dataCollectionState = 'COMPLETE';
                movementDisplay.textContent = 'Analysis complete. Monitoring breaths.';
                isMonitoringBreaths = true; 
                startButton.disabled = false; 
                collectDataButton.disabled = false; 
                collectDataButton.textContent = 'Re-Collect Data (1-Min)';
                lastBeta = null; 
                breathState = 'IDLE';
                resetChartData(); // Clear data collected during analysis, start fresh for monitoring.
            }, 500); 
        }

        async function requestAndStartSystem() { /* ... (same logic, add chart init) ... */ 
            logMessage('Requesting permissions...');
            let permGranted = false;
            // ... (permission logic same as before) ...
            if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
                try { const p = await DeviceMotionEvent.requestPermission(); if (p==='granted'){logMessage('Sensor permission granted.'); permGranted=true;} else {logMessage('Sensor permission denied.','ERROR');alert('Permission denied.');}} catch (e) {logMessage(`Perm error: ${e}`,'ERROR');alert('Perm error.');}
            } else if (window.DeviceOrientationEvent || window.DeviceMotionEvent) {logMessage('Sensors available (no explicit perm needed or already granted).'); permGranted=true;} else {logMessage('Sensor APIs not supported.','ERROR');alert('Sensor APIs not supported.');}


            if (permGranted) {
                systemActive = true; 
                initializeAudioContext(); await lockScreenOrientation();
                initBreathChart(); // Initialize the chart
                
                if (!window.eventListenersAttached) {
                    window.addEventListener('deviceorientation', handleOrientationEvent);
                    window.addEventListener('devicemotion', handleMotionEvent); 
                    window.eventListenersAttached = true; logMessage('Sensor listeners attached.');
                }
                startButton.textContent = 'Stop System';
                movementDisplay.textContent = 'System active. Tap "Start 1-Min Data Collection".';
                collectDataButton.style.display = 'inline-block'; collectDataButton.disabled = false;
                learnedThresholdDisplay.textContent = '--';
            }
            startButton.disabled = false; 
        }

        function stopSystem() { /* ... (same, clear chart data) ... */ 
            logMessage('Stopping system.'); 
            if (dataCollectionTimer) clearTimeout(dataCollectionTimer);
            dataCollectionState = 'IDLE'; 
            
            if (window.eventListenersAttached) {
                window.removeEventListener('deviceorientation', handleOrientationEvent);
                window.removeEventListener('devicemotion', handleMotionEvent);
                window.eventListenersAttached = false; logMessage('Sensor listeners removed.');
            }
            resetChartData();
            resetAppState();
        }

        function resetAppState() { /* ... (same) ... */
            systemActive = false; isMonitoringBreaths = false;
            startButton.textContent = 'Start System'; startButton.disabled = false;
            collectDataButton.style.display = 'none'; collectDataButton.disabled = true; collectDataButton.textContent = 'Start 1-Min Data Collection';
            lastBeta = null; breathState = 'IDLE'; breathTimestamps = [];
            dataCollectionState = 'IDLE'; recordedBetaValues = []; 
            LEARNED_BETA_TILT_THRESHOLD = 0.1; 
            learnedThresholdDisplay.textContent = '--';
            
            movementDisplay.textContent = '--'; breathRateDisplay.textContent = '--';
            betaGyroDisplay.textContent = '--';  zAccelDisplay.textContent = '--';
            
            if(window.eventListenersAttached) { 
                window.removeEventListener('deviceorientation', handleOrientationEvent);
                window.removeEventListener('devicemotion', handleMotionEvent);
                window.eventListenersAttached = false;
            }
        }

        function handleMotionEvent(event) { /* ... (same) ... */ 
             if (systemActive && event.accelerationIncludingGravity && event.accelerationIncludingGravity.z !== null) {
                zAccelDisplay.textContent = event.accelerationIncludingGravity.z.toFixed(3);
            } else if (!systemActive) { zAccelDisplay.textContent = 'N/A'; }
        }

        function handleOrientationEvent(event) {
            if (!systemActive || event.beta === null) {
                if (!systemActive) betaGyroDisplay.textContent = 'N/A'; return;
            }
            const currentBeta = event.beta;
            betaGyroDisplay.textContent = currentBeta.toFixed(3); 
            updateBreathChart(currentBeta); // Update chart with every new Beta value

            if (dataCollectionState === 'COLLECTING') {
                recordedBetaValues.push(currentBeta); 
                return; 
            }
            if (!isMonitoringBreaths || dataCollectionState !== 'COMPLETE') return; 
            if (lastBeta === null) { lastBeta = currentBeta; return; }

            const deltaBeta = currentBeta - lastBeta;
            const currentTime = Date.now();

            if (breathState === 'IDLE' || breathState === 'FALLING') {
                if (deltaBeta > LEARNED_BETA_TILT_THRESHOLD) { 
                    breathState = 'RISING';
                    movementDisplay.textContent = 'Inhaling (Tilt Up)';
                    playBeep();
                }
            } else if (breathState === 'RISING') {
                if (deltaBeta < -LEARNED_BETA_TILT_THRESHOLD) { 
                    breathState = 'FALLING';
                    movementDisplay.textContent = 'Exhaling (Tilt Down)';
                    if (currentTime - lastBreathEventTime > MIN_BREATH_INTERVAL_MS) {
                        breathTimestamps.push(currentTime);
                        if (breathTimestamps.length > MAX_TIMESTAMPS_FOR_BPM) breathTimestamps.shift();
                        lastBreathEventTime = currentTime;
                        calculateBreathRate();
                    }
                }
            }
            lastBeta = currentBeta;
        }
        
        function calculateBreathRate() { /* ... (same) ... */ 
            if (breathTimestamps.length < 2) { breathRateDisplay.textContent = '--'; return; }
            const durationS = (breathTimestamps[breathTimestamps.length - 1] - breathTimestamps[0]) / 1000;
            const numBreaths = breathTimestamps.length - 1;
            if (durationS > 0) {
                const bpm = (numBreaths / durationS) * 60;
                breathRateDisplay.textContent = bpm.toFixed(1);
            } else { breathRateDisplay.textContent = '--'; }
        }

        startButton.addEventListener('click', async () => {
            startButton.disabled = true; 
            if (!systemActive) {
                if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) {
                     logMessage('CRITICAL: Page not served over HTTPS.', 'ERROR');
                     alert('For sensor access on iOS, this page MUST be served over HTTPS.');
                }
                await requestAndStartSystem();
            } else { stopSystem(); }
        });

        collectDataButton.addEventListener('click', () => { startDataCollection(); });

        window.eventListenersAttached = false; 
        resetAppState();
        logMessage('App initialized. Set phone, then Start System.');
        if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) {
            logMessage('WARNING: Page not HTTPS. Sensor access may fail.', 'WARN');
        } else { logMessage('Page served over HTTPS or localhost. Good.', 'INFO'); }
    </script>
</body>
</html>
